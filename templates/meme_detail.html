<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ (meme.title if meme.media_type == 'album' and meme.title) or meme.file_name }} - Memelet</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/meme_detail.css') }}">
    <style>
        @media (max-width: 600px) {
            .back-button {
                display: block;
                text-align: center;
                width: 100%;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="navigation">
            <a href="/" class="back-button">‚Üê Back to Collection</a>
            <div>
                {% if prev_id %}
                <a href="/meme/{{ prev_id }}?{{ query_string }}" class="nav-button prev">‚Üê Previous</a>
                {% else %}
                <span class="nav-button prev disabled">‚Üê Previous</span>
                {% endif %}
                
                {% if next_id %}
                <a href="/meme/{{ next_id }}?{{ query_string }}" class="nav-button next">Next ‚Üí</a>
                {% else %}
                <span class="nav-button next disabled">Next ‚Üí</span>
                {% endif %}
            </div>
        </div>
        
        <div class="content-wrapper">
            <div class="image-section">
                {% if meme.media_type == 'album' %}
                <img id="albumMain" src="{{ (album_items[0].url) if album_items else meme.image_url }}" class="album-main" alt="{{ meme.title or meme.file_name }}">
                {% if album_items and (album_items|length) > 1 %}
                <div class="thumb-strip" id="thumbStrip" data-album-id="{{ meme.id }}">
                    {% for it in album_items %}
                    <div class="thumb-item" draggable="true" data-path="{{ it.path }}">
                        <img src="{{ it.url }}" onclick="document.getElementById('albumMain').src='{{ it.url }}'" alt="thumb {{ loop.index }}">
                    </div>
                    {% endfor %}
                </div>
                <div style="display:flex; gap:10px; margin-top:10px; align-items:center;">
                    <button type="button" id="saveOrderBtn" class="btn btn-primary" style="display:none;" onclick="saveAlbumOrder()">Save Order</button>
                    <span id="orderStatus" style="color:#718096; font-size:0.9rem;"></span>
                </div>
                {% endif %}
                {% elif meme.video_url %}
                <video controls class="meme-video">
                    <source src="{{ meme.video_url }}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                {% else %}
                <img src="{{ meme.image_url }}" alt="{{ meme.file_name }}" class="meme-image">
                {% endif %}
                <div class="image-info">
                    {% if meme.media_type == 'album' and meme.title %}
                    <strong>Album:</strong> {{ meme.title }}<br>
                    {% endif %}
                    {% if meme.media_type != 'album' %}
                    <strong>Filename:</strong> {{ meme.file_name }}<br>
                    {% endif %}
                    <strong>Path:</strong> {{ meme.display_path }}<br>
                    <strong>Added:</strong> {{ meme.created_at }}<br>
                    {% if meme.updated_at %}
                    <strong>Updated:</strong> {{ meme.updated_at }}<br>
                    {% endif %}
                    {% if meme.error_message %}
                    <div style="color: #e53e3e; font-size: 0.9rem; margin-top: 8px; padding: 8px 12px; background: #fed7d7; border-radius: 6px; border-left: 4px solid #e53e3e;">
                        <strong>‚ö†Ô∏è Error:</strong> {{ meme.error_message }}
                    </div>
                    {% endif %}
                </div>
                <div style="margin-top: 15px; display:flex; gap:10px; align-items:center; flex-wrap: wrap;">
                    <button type="button" class="btn btn-warning" onclick="processThisMeme()">Analyze This Meme</button>
                    <span id="processStatus" data-initial-updated-at="{{ meme.updated_at or '' }}" style="color:#718096; font-size:0.9rem;"></span>
                    <button type="button" class="btn" onclick="scanTagsThisMeme()">üîé Scan Tags</button>
                    <span id="tagScanStatus" data-initial-updated-at="{{ meme.updated_at or '' }}" style="color:#718096; font-size:0.9rem;"></span>
                </div>
            </div>
            
            <div class="form-section">
                <h1>Meme Details</h1>
                
                <form method="POST">
                    <!-- Preserve filter parameters -->
                    <input type="hidden" name="search" value="{{ request.args.get('search', '') }}">
                    <input type="hidden" name="status_filter" value="{{ request.args.get('status', '') }}">
                    <input type="hidden" name="tag_filter" value="{{ request.args.get('tag', '') }}">
                    <input type="hidden" name="media_filter" value="{{ request.args.get('media', '') }}">
                    
                    {% if meme.media_type == 'album' %}
                    <div class="form-group">
                        <label for="title">Album Title</label>
                        <input type="text" name="title" id="title" value="{{ meme.title }}" placeholder="Album title">
                    </div>
                    {% endif %}

                    <div class="form-group">
                        <label for="status">Status</label>
                        <select name="status" id="status">
                            <option value="new" {% if meme.status == 'new' %}selected{% endif %}>New</option>
                            <option value="done" {% if meme.status == 'done' %}selected{% endif %}>Done</option>
                            <option value="error" {% if meme.status == 'error' %}selected{% endif %}>Error</option>
                            <option value="reviewed" {% if meme.status == 'reviewed' %}selected{% endif %}>Reviewed</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Tags</label>
                        <div class="tag-selector">
                            {% if all_tags %}
                                {% for tag in all_tags %}
                                <label class="tag-chip {% if tag.id in current_tags %}selected{% endif %}" 
                                       style="background-color: {{ tag.color }}">
                                    <input type="checkbox" 
                                           name="tags" 
                                           value="{{ tag.id }}" 
                                           {% if tag.id in current_tags %}checked{% endif %}
                                           onchange="this.parentElement.classList.toggle('selected', this.checked)">
                                    {{ tag.name }}
                                </label>
                                {% endfor %}
                            {% else %}
                                <span style="color: #a0aec0;">No tags created yet. <a href="/tags" style="color: #667eea;">Create tags</a></span>
                            {% endif %}
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="caption">Caption</label>
                        <textarea name="caption" id="caption" placeholder="Meme caption text">{{ meme.caption }}</textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="description">Description</label>
                        <textarea name="description" id="description" placeholder="What's happening in this meme?">{{ meme.description }}</textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="meaning">Meaning</label>
                        <textarea name="meaning" id="meaning" placeholder="What does this meme mean?">{{ meme.meaning }}</textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="template">Template</label>
                        <textarea name="template" id="template" placeholder="e.g., Drake, Distracted Boyfriend">{{ meme.template }}</textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="ref_content">References</label>
                        <textarea name="ref_content" id="ref_content" placeholder="Characters, shows, movies, or famous people">{{ meme.ref_content }}</textarea>
                    </div>
                    
                    <div class="button-group">
                        <button type="submit" class="btn btn-primary">Save Changes</button>
                        <a href="/" class="btn btn-secondary">Cancel</a>
                    </div>
                </form>
                
                <div class="delete-section">
                    <div class="danger-zone">
                        <h3>‚ö†Ô∏è Danger Zone</h3>
                        <p>This will permanently delete the meme from both the database and filesystem. This action cannot be undone.</p>
                        <button onclick="deleteMeme()" class="btn btn-danger">Delete Meme</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Auto-resize textareas to fit content on load and input
        (function autoResizeTextareas() {
            const areas = document.querySelectorAll('textarea');
            const MIN_PX = 100;

            function resize(el) {
                el.style.height = 'auto';
                el.style.overflow = 'hidden';
                el.style.height = Math.max(el.scrollHeight, MIN_PX) + 'px';
            }

            areas.forEach(el => {
                resize(el);
                el.addEventListener('input', () => resize(el));
            });

            window.addEventListener('load', () => areas.forEach(resize));
        })();

        function processThisMeme() {
            const statusEl = document.getElementById('processStatus');
            statusEl.textContent = 'Starting‚Ä¶';
            fetch('/api/memes/{{ meme.id }}/process', {
                method: 'POST',
                headers: { 'Accept': 'application/json' }
            })
            .then(r => r.json().catch(() => ({})).then(j => ({ ok: r.ok, body: j })))
            .then(({ ok, body }) => {
                if (!ok || !body.success) {
                    throw new Error((body && (body.error || body.message)) || 'Request failed');
                }
                statusEl.textContent = 'Processing‚Ä¶';
                startMemePolling();
            })
            .catch(err => {
                statusEl.textContent = 'Error: ' + err.message;
            });
        }

        function scanTagsThisMeme() {
            const statusEl = document.getElementById('tagScanStatus');
            statusEl.textContent = 'Starting‚Ä¶';
            const baseline = getCurrentTagSet();
            fetch('/api/memes/{{ meme.id }}/scan-tags', {
                method: 'POST',
                headers: { 'Accept': 'application/json' }
            })
            .then(r => r.json().catch(() => ({})).then(j => ({ ok: r.ok, body: j })))
            .then(({ ok, body }) => {
                if (!ok || !body.success) {
                    throw new Error((body && (body.error || body.message)) || 'Request failed');
                }
                statusEl.textContent = 'Started';
                if (body.job_id) {
                    pollTagScanJob(body.job_id, baseline);
                } else {
                    // Fallback if job_id isn't returned for some reason
                    startTagScanPolling(baseline);
                }
            })
            .catch(err => {
                statusEl.textContent = 'Error: ' + err.message;
            });
        }

        function pollTagScanJob(jobId, baselineSet){
            const statusEl = document.getElementById('tagScanStatus');
            let ticks = 0;
            const maxTicks = 120; // ~2 minutes
            const id = {{ meme.id }};
            function finish(applied){
                fetch(`/api/memes/${id}?t=${Date.now()}`, { cache: 'no-store' })
                  .then(r => r.json())
                  .then(data => {
                      if (data && data.success && data.meme && Array.isArray(data.meme.tag_ids)){
                          const set = new Set(data.meme.tag_ids.map(v => parseInt(v, 10)));
                          applyTagSet(set);
                      }
                  })
                  .finally(() => {
                      statusEl.textContent = applied ? 'Completed' : 'No changes';
                  });
            }
            function tick(){
                fetch(`/api/jobs/${jobId}/status?t=${Date.now()}`, { cache: 'no-store' })
                  .then(r => r.json())
                  .then(data => {
                      if (!data || !data.success) throw new Error('Status fetch failed');
                      if (data.status === 'completed') {
                          finish(Boolean(data.applied));
                          return;
                      }
                      // Early exit if tags already changed
                      fetch(`/api/memes/${id}?t=${Date.now()}`, { cache: 'no-store' })
                        .then(r => r.json())
                        .then(m => {
                            if (m && m.success && m.meme && Array.isArray(m.meme.tag_ids)){
                                const newSet = new Set(m.meme.tag_ids.map(v => parseInt(v, 10)));
                                let changed = newSet.size !== baselineSet.size;
                                if (!changed){
                                    for (const v of newSet){ if (!baselineSet.has(v)) { changed = true; break; } }
                                }
                                if (changed){
                                    applyTagSet(newSet);
                                    statusEl.textContent = 'Completed';
                                    return;
                                }
                            }
                            ticks++;
                            if (ticks >= maxTicks){
                                statusEl.textContent = 'No changes';
                            } else {
                                statusEl.textContent = 'Processing‚Ä¶';
                                setTimeout(tick, 1000);
                            }
                        });
                  })
                  .catch(() => {
                      ticks++;
                      if (ticks >= maxTicks){
                          statusEl.textContent = 'No changes';
                      } else {
                          statusEl.textContent = 'Processing‚Ä¶';
                          setTimeout(tick, 1000);
                      }
                  });
            }
            tick();
        }

        function getCurrentTagSet(){
            const boxes = document.querySelectorAll('.tag-selector input[type="checkbox"]');
            const set = new Set();
            boxes.forEach(cb => { if (cb.checked) set.add(parseInt(cb.value, 10)); });
            return set;
        }

        function applyTagSet(newSet){
            const boxes = document.querySelectorAll('.tag-selector input[type="checkbox"]');
            boxes.forEach(cb => {
                const tagId = parseInt(cb.value, 10);
                const should = newSet.has(tagId);
                if (cb.checked !== should){
                    cb.checked = should;
                }
                const wrap = cb.parentElement;
                if (wrap){
                    wrap.classList.toggle('selected', should);
                }
            });
        }

        let tagPollTimer = null;
        function startTagScanPolling(baselineSet){
            if (tagPollTimer) clearInterval(tagPollTimer);
            const statusEl = document.getElementById('tagScanStatus');
            const id = {{ meme.id }};
            const baselineUpdatedAt = statusEl.getAttribute('data-initial-updated-at') || '';
            let ticks = 0;
            const maxTicks = 120; // ~2 minutes
            const tick = () => {
                fetch(`/api/memes/${id}?t=${Date.now()}` , { cache: 'no-store' })
                  .then(r => r.json())
                  .then(data => {
                      if (!data || !data.success) throw new Error('Status fetch failed');
                      const m = data.meme;
                      const newSet = new Set((m.tag_ids || []).map(v => parseInt(v, 10)));
                      const updatedAt = (m.updated_at || '');
                      // Compare sets (size or membership differences)
                      let changed = newSet.size !== baselineSet.size;
                      if (!changed){
                          for (const v of newSet){ if (!baselineSet.has(v)) { changed = true; break; } }
                      }
                      if (changed || (updatedAt && updatedAt !== baselineUpdatedAt)){
                          applyTagSet(newSet);
                          statusEl.textContent = 'Completed';
                          clearInterval(tagPollTimer);
                          tagPollTimer = null;
                      } else {
                          ticks++;
                          if (ticks >= maxTicks){
                              statusEl.textContent = 'No changes';
                              clearInterval(tagPollTimer);
                              tagPollTimer = null;
                          } else {
                              statusEl.textContent = 'Processing‚Ä¶';
                          }
                      }
                  })
                  .catch((e) => {
                      clearInterval(tagPollTimer);
                      tagPollTimer = null;
                      statusEl.textContent = 'Error: ' + (e && e.message ? e.message : 'Polling failed');
                  });
            };
            tick();
            tagPollTimer = setInterval(tick, 1000);
        }

        let pollTimer = null;
        let seenProcessing = false;
        let firstSeenUpdatedAt = null;
        function startMemePolling(){
            if (pollTimer) clearInterval(pollTimer);
            seenProcessing = false;
            firstSeenUpdatedAt = null;
            const statusEl = document.getElementById('processStatus');
            const id = {{ meme.id }};
            const baselineUpdatedAt = statusEl.getAttribute('data-initial-updated-at') || '';
            function applyValues(m){
                const map = [
                    ['caption','caption'],
                    ['description','description'],
                    ['meaning','meaning'],
                    ['template','template'],
                    ['ref_content','ref_content']
                ];
                for (const [field, elId] of map){
                    const el = document.getElementById(elId);
                    if (el && typeof m[field] === 'string'){
                        el.value = m[field];
                        // inline resize
                        el.style.height = 'auto';
                        el.style.overflow = 'hidden';
                        el.style.height = Math.max(el.scrollHeight, 100) + 'px';
                    }
                }
                // Update tag checkboxes to reflect current DB state
                if (Array.isArray(m.tag_ids)){
                    const set = new Set(m.tag_ids.map(v => parseInt(v, 10)));
                    const boxes = document.querySelectorAll('.tag-selector input[type="checkbox"]');
                    boxes.forEach(cb => {
                        const tagId = parseInt(cb.value, 10);
                        const should = set.has(tagId);
                        if (cb.checked !== should){
                            cb.checked = should;
                        }
                        const wrap = cb.parentElement;
                        if (wrap){
                            wrap.classList.toggle('selected', should);
                        }
                    });
                }
            }
            const tick = () => {
                fetch(`/api/memes/${id}?t=${Date.now()}` , { cache: 'no-store' })
                  .then(r => r.json())
                  .then(data => {
                      if (!data || !data.success) throw new Error('Status fetch failed');
                      const m = data.meme;
                      if (firstSeenUpdatedAt === null) firstSeenUpdatedAt = m.updated_at || '';
                      const st = (m.status || '').toLowerCase();
                      if (st === 'processing' || st === 'new' || st === 'error' || st === 'done'){
                          if (st === 'processing'){
                              seenProcessing = true;
                              statusEl.textContent = 'Processing‚Ä¶';
                          } else if (st === 'done'){
                              // Accept completion when updated_at changed since the first poll of this run
                              if (m.updated_at && m.updated_at !== firstSeenUpdatedAt){
                                  // Small delay to ensure readers see committed values
                                  setTimeout(() => {
                                      fetch(`/api/memes/${id}?t=${Date.now()}` , { cache: 'no-store' })
                                        .then(r2 => r2.json())
                                        .then(d2 => { if (d2 && d2.success) applyValues(d2.meme); })
                                        .finally(() => {
                                            statusEl.textContent = 'Completed';
                                            clearInterval(pollTimer);
                                            pollTimer = null;
                                        });
                                  }, 300);
                              } else {
                                  // Not yet reflected; continue polling, keep UX as Processing
                                  statusEl.textContent = 'Processing‚Ä¶';
                              }
                          } else if (st === 'error'){
                              statusEl.textContent = 'Error: ' + (m.error_message || 'Processing failed');
                              clearInterval(pollTimer);
                              pollTimer = null;
                          } else {
                              statusEl.textContent = 'Processing‚Ä¶';
                          }
                      }
                  })
                  .catch((e) => {
                      // On fetch error, offer manual refresh
                      clearInterval(pollTimer);
                      pollTimer = null;
                      statusEl.textContent = 'Error: ' + (e && e.message ? e.message : 'Polling failed');
                  });
            };
            tick();
            pollTimer = setInterval(tick, 1000);
        }

        // Drag & drop thumbnail reordering for albums
        (function(){
            const strip = document.getElementById('thumbStrip');
            if (!strip) return;
            let dragEl = null;
            const initialOrder = Array.from(strip.querySelectorAll('.thumb-item')).map(div => div.getAttribute('data-path'));
            strip.addEventListener('dragstart', (e) => {
                const item = e.target.closest('.thumb-item');
                if (!item) return;
                dragEl = item;
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            strip.addEventListener('dragend', (e) => {
                const item = e.target.closest('.thumb-item');
                if (item) item.classList.remove('dragging');
                dragEl = null;
                toggleSaveButton();
            });
            strip.addEventListener('dragover', (e) => {
                e.preventDefault();
                const after = getDragAfterElement(strip, e.clientX);
                if (after == null) {
                    strip.appendChild(dragEl);
                } else {
                    strip.insertBefore(dragEl, after);
                }
            });
            function getDragAfterElement(container, x) {
                const els = [...container.querySelectorAll('.thumb-item:not(.dragging)')];
                return els.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - (box.left + box.width / 2);
                    if (offset < 0 && offset > closest.offset) {
                        return { offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }
            function toggleSaveButton(){
                const current = Array.from(strip.querySelectorAll('.thumb-item')).map(div => div.getAttribute('data-path'));
                const changed = current.length !== initialOrder.length || current.some((p, i) => p !== initialOrder[i]);
                const btn = document.getElementById('saveOrderBtn');
                if (btn) btn.style.display = changed ? 'inline-block' : 'none';
            }
        })();

        function saveAlbumOrder() {
            const strip = document.getElementById('thumbStrip');
            if (!strip) return;
            const albumId = parseInt(strip.getAttribute('data-album-id'));
            const items = Array.from(strip.querySelectorAll('.thumb-item')).map(div => div.getAttribute('data-path'));
            const statusEl = document.getElementById('orderStatus');
            statusEl.textContent = 'Saving...';
            fetch(`/api/albums/${albumId}/order`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify({ items })
            })
            .then(async r => {
                const text = await r.text();
                let data;
                try { data = text ? JSON.parse(text) : {}; } catch (e) { throw new Error(text || 'Non-JSON response'); }
                if (!r.ok || !data.success) {
                    const msg = (data && data.error) ? data.error : (text || 'Request failed');
                    throw new Error(msg);
                }
                return data;
            })
            .then(() => {
                statusEl.textContent = 'Saved';
                setTimeout(() => statusEl.textContent = '', 1500);
            })
            .catch(err => {
                statusEl.textContent = 'Error: ' + err.message;
            });
        }
        function deleteMeme() {
            if (!confirm('Are you sure you want to permanently delete this meme?\n\nThis will delete:\n- The database entry\n- All tags\n- The image file\n\nThis action cannot be undone!')) {
                return;
            }
            
            fetch('/api/memes/{{ meme.id }}', {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    window.location.href = '/';
                } else {
                    alert('Error deleting meme: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                alert('Error deleting meme: ' + error);
            });
        }
    </script>
</body>
</html>