<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settings - Memelet</title>
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/settings.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='clippy/build/clippy.css') }}"
        media="all">
</head>

<body>
    <div class="container settings-page">
        <div class="settings-header-wrapper">
            <div class="settings-navigation">
                <a href="{{ base_url }}/" class="back-button">‚Üê Back</a>
                <a href="{{ base_url }}/logout" class="back-button">üö™ Logout</a>
            </div>
            <h1>‚öôÔ∏è Settings</h1>
        </div>

        <div class="section">
            <h2>Manual Actions</h2>

            <div id="message-container"></div>

            <p class="action-description">
                Trigger manual scans and processing. The automated scan runs every hour.
            </p>

            <div class="manual-actions-buttons">
                <button type="button" class="btn btn-primary" id="scan-btn" onclick="triggerAction('scan')">
                    üîç Scan & Process New Memes
                </button>

                <button type="button" class="btn btn-warning" id="retry-btn" onclick="triggerAction('retry_errors')">
                    üîÑ Reprocess Errors
                </button>

                <button type="button" class="btn" id="scan-tags-btn" onclick="triggerAction('scan_tags_all')">
                    üîé Scan Tags (All Memes)
                </button>
            </div>
        </div>

        <div class="section">
            <h2>üì¶ Version Information</h2>
            <p class="action-description" id="version-description">
                Loading version information...
            </p>
            <div class="version-info-container" id="version-info-container" style="display: none;">
                <div class="version-info-item" style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: #374151;">Current Version:</span>
                        <span id="current-version-display" style="color: #6b7280;">-</span>
                    </div>
                </div>
                <div class="version-info-item" style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: #374151;">Branch:</span>
                        <span id="current-branch-display" style="color: #6b7280;">-</span>
                    </div>
                </div>
                <div class="version-info-item" style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: #374151;">Available Version:</span>
                        <span id="available-version-display" style="color: #6b7280;">-</span>
                    </div>
                </div>
                <div class="version-info-item" id="update-status-container" style="display: none; margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
                    <div id="update-status-message" style="color: #059669; font-weight: 500;"></div>
                    <button 
                        id="update-button" 
                        class="btn btn-primary" 
                        style="display: none; margin-top: 12px; width: 100%;"
                        onclick="initiateUpdate()"
                    >
                        üîÑ Update Now
                    </button>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Latest Scan Activity</h2>
            <p class="action-description">
                Most recent scan log entry (auto-refreshes every 10 seconds)
            </p>
            <div class="log-container" id="log-content">{{ log_content }}</div>
        </div>

        <div class="section">
            <h2>üíæ Disk Usage</h2>
            <p class="action-description" id="disk-usage-description">
                Loading disk usage information...
            </p>
            <div class="disk-usage-container">
                <div class="progress-bar-container">
                    <div class="progress-bar" id="disk-usage-bar" style="width: 0%; background-color: #10b981;"></div>
                </div>
                <div class="disk-usage-info" id="disk-usage-info">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="section" id="replicate-usage-section" style="display: none;">
            <h2>ü§ñ Replicate Usage</h2>
            <p class="action-description" id="replicate-usage-description">
                <!-- Will be populated by JavaScript when a managed quota is configured -->
            </p>
            <div class="disk-usage-container">
                <div class="progress-bar-container">
                    <div class="progress-bar" id="replicate-usage-bar" style="width: 0%; background-color: #10b981;"></div>
                </div>
                <div class="disk-usage-info" id="replicate-usage-info">
                    <!-- Will be populated by JavaScript when a managed quota is configured -->
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üîë Replicate API Key</h2>
            
            <!-- AI Functions Toggle -->
            <div style="margin-bottom: 20px; padding: 15px; background: #f7fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <strong style="font-size: 1.05rem;">ü§ñ AI Functions</strong>
                        <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: #718096;">
                            Enklable AI-powered description generation and tag suggestions
                        </p>
                    </div>
                    <label class="toggle-switch" style="margin-left: 20px;">
                        <input type="checkbox" id="ai-enabled-toggle" onchange="toggleAiFunctions()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div id="ai-status-message" style="margin-top: 10px; font-size: 0.85rem;"></div>
            </div>

            <!-- API Key Configuration Block -->
            <div id="api-key-config-block">
            {% if api_key_configured_externally %}
            <p class="action-description">
                <strong>‚úÖ API Key Configured via Environment:</strong> An API key is provided by the environment. No
                manual configuration needed!
            </p>
            <div style="margin-top: 15px;">
                <button type="button" class="btn" id="show-custom-key-btn" onclick="showCustomKeyForm()">
                    üîë Use Custom API Key Instead
                </button>
            </div>
            <div id="custom-key-form"
                style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                <p class="action-description">
                    Provide your own Replicate API key to use direct billing. Get your key from <a
                        href="https://replicate.com/account/api-tokens" target="_blank"
                        rel="noopener noreferrer">replicate.com/account/api-tokens</a>
                </p>
                <div class="api-key-form">
                    <input type="password" id="api-key-input" placeholder="Enter your Replicate API key">
                    <div class="api-key-buttons">
                        <button type="button" class="btn btn-primary" onclick="saveApiKey()">üíæ Save API Key</button>
                        <button type="button" class="btn" id="show-hide-btn" onclick="toggleApiKeyVisibility()"
                            style="display: none;">üëÅÔ∏è Show/Hide</button>
                        <button type="button" class="btn" onclick="clearApiKey()">üóëÔ∏è Clear</button>
                    </div>
                </div>
                <div id="api-key-status" style="margin-top: 10px; font-size: 0.9rem;"></div>
                <div id="api-key-message" style="margin-top: 10px;"></div>
                <p style="margin-top: 10px; font-size: 0.85rem; color: #666;">
                    <strong>Note:</strong> For security, saved API keys are masked and cannot be retrieved. To change
                    the key, clear the field and enter a new one.
                </p>
            </div>
            {% else %}
            <p class="action-description">
                Configure your Replicate API key for AI-powered meme analysis. Get your key from <a
                    href="https://replicate.com/account/api-tokens" target="_blank"
                    rel="noopener noreferrer">replicate.com/account/api-tokens</a>
            </p>
            <div class="api-key-form">
                <input type="password" id="api-key-input" placeholder="Enter your Replicate API key">
                <div class="api-key-buttons">
                    <button type="button" class="btn btn-primary" onclick="saveApiKey()">üíæ Save API Key</button>
                    <button type="button" class="btn" id="show-hide-btn" onclick="toggleApiKeyVisibility()"
                        style="display: none;">üëÅÔ∏è Show/Hide</button>
                    <button type="button" class="btn" onclick="clearApiKey()">üóëÔ∏è Clear</button>
                </div>
            </div>
            <div id="api-key-status" style="margin-top: 10px; font-size: 0.9rem;"></div>
            <div id="api-key-message" style="margin-top: 10px;"></div>
            <p style="margin-top: 10px; font-size: 0.85rem; color: #666;">
                <strong>Note:</strong> For security, saved API keys are masked and cannot be retrieved. To change the
                key, clear the field and enter a new one.
            </p>
            {% endif %}
            </div>
            <!-- End API Key Configuration Block -->
        </div>

        <div class="section">
            <h2>üîê Account Security</h2>
            <p class="action-description">
                Manage your account credentials.
            </p>
            <div class="password-change-form">
                <div style="margin-bottom: 15px;">
                    <label for="username-display" style="display: block; margin-bottom: 5px; font-weight: 500;">Your
                        Login</label>
                    <input type="text" id="username-display" value="{{ username }}" readonly
                        style="width: 400px; max-width: 100%; padding: 10px; background: #f7fafc; cursor: not-allowed; color: #4a5568;">
                </div>
                <button type="button" class="btn btn-primary" id="show-password-fields-btn"
                    onclick="showPasswordFields()">üîí Change Password</button>

                <div id="password-fields"
                    style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                    <div style="margin-bottom: 15px;">
                        <label for="current-password"
                            style="display: block; margin-bottom: 5px; font-weight: 500;">Current Password</label>
                        <input type="password" id="current-password" placeholder="Enter current password"
                            style="width: 400px; max-width: 100%; padding: 10px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label for="new-password" style="display: block; margin-bottom: 5px; font-weight: 500;">New
                            Password</label>
                        <input type="password" id="new-password" placeholder="Enter new password (min 4 characters)"
                            style="width: 400px; max-width: 100%; padding: 10px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label for="confirm-password"
                            style="display: block; margin-bottom: 5px; font-weight: 500;">Confirm New Password</label>
                        <input type="password" id="confirm-password" placeholder="Confirm new password"
                            style="width: 400px; max-width: 100%; padding: 10px;">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button type="button" class="btn btn-primary" onclick="submitPasswordChange()">üíæ Save New
                            Password</button>
                        <button type="button" class="btn" onclick="hidePasswordFields()">Cancel</button>
                    </div>
                </div>
            </div>
            <div id="password-message" style="margin-top: 10px;"></div>
        </div>

        <div class="section">
            <h2>üîí Privacy Mode</h2>
            <p class="action-description">
                Control who can view your Memelet collection.
            </p>
            <div class="privacy-mode-selector">
                <label>
                    <input type="radio" name="privacy-mode" value="private">
                    <div>
                        <strong>üîê Private (Default)</strong>
                        <span>Only authenticated users can access your Memelet. Login required for all pages.</span>
                    </div>
                </label>
                <label>
                    <input type="radio" name="privacy-mode" value="public">
                    <div>
                        <strong>üåç Public</strong>
                        <span>Visitors can view memes and descriptions (read-only). Settings and editing require
                            authentication.</span>
                    </div>
                </label>
            </div>
            <div id="privacy-mode-message" style="margin-top: 10px;"></div>
        </div>

        <div class="section">
            <h2>Clippy Agent Appearance</h2>
            <p class="action-description">
                Select which assistant agent to display, or choose "None" to disable Clippy
            </p>
            <div class="agent-selector" id="agentSelector">
                <!-- Agent previews will be generated here -->
            </div>
            <div id="agent-message" style="margin-top: 15px;"></div>
        </div>
    </div>

    <script>
        let isProcessing = false;
        let logCheckInterval;

        function triggerAction(action) {
            // Disable buttons
            isProcessing = true;
            document.getElementById('scan-btn').disabled = true;
            document.getElementById('retry-btn').disabled = true;
            const scanTagsBtn = document.getElementById('scan-tags-btn');
            if (scanTagsBtn) scanTagsBtn.disabled = true;

            if (action === 'scan') {
                document.getElementById('scan-btn').textContent = '‚è≥ Processing...';
            } else if (action === 'retry_errors') {
                document.getElementById('retry-btn').textContent = '‚è≥ Processing...';
            } else if (action === 'scan_tags_all') {
                if (scanTagsBtn) scanTagsBtn.textContent = '‚è≥ Processing...';
            }

            // Show message
            showMessage('Starting process... Check the log below for progress.', 'success');

            // Trigger action via AJAX
            fetch(`${BASE_URL}/api/trigger-action`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ action: action })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showMessage(data.message, 'success');
                        // Start checking log for completion
                        logCheckInterval = setInterval(checkIfProcessingComplete, 2000);
                    } else {
                        showMessage(data.message, 'error');
                        enableButtons();
                    }
                })
                .catch(error => {
                    showMessage('Error triggering action: ' + error, 'error');
                    enableButtons();
                });
        }

        function showMessage(text, type) {
            const container = document.getElementById('message-container');
            container.innerHTML = `<div class="message ${type}">${text}</div>`;
        }

        function enableButtons() {
            isProcessing = false;
            document.getElementById('scan-btn').disabled = false;
            document.getElementById('retry-btn').disabled = false;
            document.getElementById('scan-btn').textContent = 'üîç Scan & Process New Memes';
            document.getElementById('retry-btn').textContent = 'üîÑ Reprocess Errors';
            const scanTagsBtn = document.getElementById('scan-tags-btn');
            if (scanTagsBtn) {
                scanTagsBtn.disabled = false;
                scanTagsBtn.textContent = 'üîé Scan Tags (All Memes)';
            }

            if (logCheckInterval) {
                clearInterval(logCheckInterval);
            }
        }

        let lastLogContent = '';

        function checkIfProcessingComplete() {
            fetch(`${BASE_URL}/settings`)
                .then(response => response.text())
                .then(html => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const newLogContent = doc.getElementById('log-content').textContent;

                    // Check if log content changed and contains completion message
                    if (newLogContent !== lastLogContent &&
                        newLogContent.includes('completed')) {
                        showMessage('‚úì Process completed!', 'success');
                        enableButtons();
                    }

                    lastLogContent = newLogContent;
                    document.getElementById('log-content').textContent = newLogContent;
                })
                .catch(error => console.error('Error checking log:', error));
        }

        // Auto-refresh log every 5 seconds
        setInterval(function () {
            if (!isProcessing) {
                fetch(`${BASE_URL}/settings`)
                    .then(response => response.text())
                    .then(html => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const newLogContent = doc.getElementById('log-content').textContent;
                        document.getElementById('log-content').textContent = newLogContent;
                    })
                    .catch(error => console.error('Error refreshing log:', error));
            }
        }, 5000);
    </script>

    <!-- API Key Management Script -->
    <script>
        // Get base URL for API calls (for multi-tenant support)
        const BASE_URL = '{{ base_url }}' || '';

        let currentApiKey = '';
        let hasExistingKey = false;

        // Load current API key on page load
        function loadApiKey() {
            fetch(`${BASE_URL}/api/settings/replicate-api-key`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const statusEl = document.getElementById('api-key-status');
                        const inputEl = document.getElementById('api-key-input');
                        if (data.has_key) {
                            hasExistingKey = true;
                            currentApiKey = data.api_key;
                            inputEl.value = data.api_key;
                            inputEl.disabled = true;
                            inputEl.style.opacity = '0.7';
                            statusEl.innerHTML = '‚úÖ API key is configured (masked for security)';
                            statusEl.style.color = '#2ecc71';
                        } else {
                            hasExistingKey = false;
                            // Don't show warning if this is a managed instance
                            // (the custom key form is hidden by default in managed mode)
                            if (!document.getElementById('custom-key-form') || document.getElementById('custom-key-form').style.display !== 'none') {
                                statusEl.innerHTML = '‚ö†Ô∏è No API key configured';
                                statusEl.style.color = '#e74c3c';
                            }
                            inputEl.disabled = false;
                            inputEl.style.opacity = '1';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading API key:', error);
                });
        }

        function clearApiKey() {
            const inputEl = document.getElementById('api-key-input');
            const showHideBtn = document.getElementById('show-hide-btn');

            inputEl.value = '';
            inputEl.disabled = false;
            inputEl.style.opacity = '1';
            inputEl.type = 'password';
            inputEl.focus();

            // Show the show/hide button when entering a new key
            showHideBtn.style.display = 'inline-block';

            const statusEl = document.getElementById('api-key-status');
            if (hasExistingKey) {
                statusEl.innerHTML = 'üìù Ready to enter new API key';
                statusEl.style.color = '#f39c12';
            }
        }

        function saveApiKey() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const showHideBtn = document.getElementById('show-hide-btn');

            if (!apiKey) {
                const msgEl = document.getElementById('api-key-message');
                msgEl.innerHTML = '<div class="message error">Please enter an API key</div>';
                setTimeout(() => msgEl.innerHTML = '', 3000);
                return;
            }

            // Don't save if it's the masked version
            if (apiKey.startsWith('‚Ä¢')) {
                const msgEl = document.getElementById('api-key-message');
                msgEl.innerHTML = '<div class="message error">Please clear the field first to enter a new key</div>';
                setTimeout(() => msgEl.innerHTML = '', 3000);
                return;
            }

            fetch(`${BASE_URL}/api/settings/replicate-api-key`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ api_key: apiKey })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const msgEl = document.getElementById('api-key-message');
                        msgEl.innerHTML = '<div class="message success">API key saved successfully!</div>';
                        setTimeout(() => msgEl.innerHTML = '', 3000);

                        // Hide show/hide button again
                        showHideBtn.style.display = 'none';

                        // Reload to show masked version
                        loadApiKey();
                        
                        // Update Replicate usage display (will hide quota section if BYOK is now active)
                        updateReplicateUsage();
                    } else {
                        const msgEl = document.getElementById('api-key-message');
                        msgEl.innerHTML = '<div class="message error">Error saving API key: ' + (data.error || 'Unknown error') + '</div>';
                        setTimeout(() => msgEl.innerHTML = '', 5000);
                    }
                })
                .catch(error => {
                    const msgEl = document.getElementById('api-key-message');
                    msgEl.innerHTML = '<div class="message error">Error saving API key: ' + error + '</div>';
                    setTimeout(() => msgEl.innerHTML = '', 5000);
                });
        }

        function toggleApiKeyVisibility() {
            const input = document.getElementById('api-key-input');
            if (input.type === 'password') {
                input.type = 'text';
            } else {
                input.type = 'password';
            }
        }

        function showCustomKeyForm() {
            document.getElementById('custom-key-form').style.display = 'block';
            document.getElementById('show-custom-key-btn').style.display = 'none';
            // Load current key state when form is shown
            loadApiKey();
        }

        // Show/hide the show/hide button when user types
        document.addEventListener('DOMContentLoaded', function () {
            loadApiKey();

            const inputEl = document.getElementById('api-key-input');
            const showHideBtn = document.getElementById('show-hide-btn');

            inputEl.addEventListener('input', function () {
                // Only show the button if field is not disabled and has content
                if (!this.disabled && this.value.length > 0) {
                    showHideBtn.style.display = 'inline-block';
                } else {
                    showHideBtn.style.display = 'none';
                }
            });
        });
    </script>

    <!-- AI Functions Toggle Script -->
    <script>
        let aiEnabled = true;

        // Load AI enabled status on page load
        function loadAiStatus() {
            fetch(`${BASE_URL}/api/settings/ai-enabled`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        aiEnabled = data.ai_enabled;
                        const toggle = document.getElementById('ai-enabled-toggle');
                        const configBlock = document.getElementById('api-key-config-block');
                        const statusMsg = document.getElementById('ai-status-message');
                        
                        toggle.checked = aiEnabled;
                        
                        if (aiEnabled) {
                            configBlock.style.display = 'block';
                            statusMsg.innerHTML = '<span style="color: #10b981;">‚úÖ AI functions are enabled</span>';
                        } else {
                            configBlock.style.display = 'none';
                            statusMsg.innerHTML = '<span style="color: #718096;">‚ÑπÔ∏è AI functions are disabled. Description generation and tag suggestions will not run.</span>';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading AI status:', error);
                });
        }

        function toggleAiFunctions() {
            const toggle = document.getElementById('ai-enabled-toggle');
            const newStatus = toggle.checked;
            
            fetch(`${BASE_URL}/api/settings/ai-enabled`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ai_enabled: newStatus })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        aiEnabled = newStatus;
                        const configBlock = document.getElementById('api-key-config-block');
                        const statusMsg = document.getElementById('ai-status-message');
                        
                        if (aiEnabled) {
                            configBlock.style.display = 'block';
                            statusMsg.innerHTML = '<span style="color: #10b981;">‚úÖ AI functions are enabled</span>';
                        } else {
                            configBlock.style.display = 'none';
                            statusMsg.innerHTML = '<span style="color: #718096;">‚ÑπÔ∏è AI functions are disabled. Description generation and tag suggestions will not run.</span>';
                        }
                    } else {
                        // Revert toggle on error
                        toggle.checked = aiEnabled;
                        alert('Error updating AI status: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('Error toggling AI status:', error);
                    // Revert toggle on error
                    toggle.checked = aiEnabled;
                    alert('Error updating AI status');
                });
        }

        // Load AI status when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadAiStatus();
        });
    </script>

    <!-- Agent Selector Script -->
    <script>
        let currentAgent = '{{ current_agent }}';

        function createAgentPreview(agent, isNone = false) {
            const preview = document.createElement('div');
            preview.className = 'agent-preview';
            preview.dataset.agent = agent ? agent.name : 'none';

            if (isNone) {
                preview.innerHTML = `
                    <div class="agent-preview-none">
                        <div class="agent-preview-icon">üö´</div>
                    </div>
                    <div class="agent-name">None</div>
                `;
            } else {
                // Create image container (80x80px)
                const container = document.createElement('div');
                container.className = 'agent-preview-image-container';

                const img = document.createElement('img');
                img.alt = agent.name;

                // Scale preview image to fit 80px height while maintaining aspect ratio
                img.onload = function () {
                    try {
                        const naturalWidth = img.naturalWidth;
                        const naturalHeight = img.naturalHeight;

                        if (naturalHeight > 0) {
                            // Calculate scale to fit 80px height
                            const scale = 80 / naturalHeight;
                            const scaledWidth = naturalWidth * scale;

                            // Set image size
                            img.style.width = `${scaledWidth}px`;
                            img.style.height = `${80}px`;
                        }
                    } catch (e) {
                        console.error('Error scaling preview image:', e);
                    }
                };

                img.onerror = function () {
                    console.error(`Failed to load preview.png for agent: ${agent.name}`);
                    // Show placeholder or agent name as fallback
                    img.style.display = 'none';
                    const placeholder = document.createElement('div');
                    placeholder.style.width = '80px';
                    placeholder.style.height = '80px';
                    placeholder.style.display = 'flex';
                    placeholder.style.alignItems = 'center';
                    placeholder.style.justifyContent = 'center';
                    placeholder.style.background = '#f0f0f0';
                    placeholder.style.color = '#666';
                    placeholder.style.fontSize = '0.8rem';
                    placeholder.textContent = agent.name.substring(0, 4);
                    container.appendChild(placeholder);
                };

                img.src = `/static/clippy/agents/${agent.name}/preview.png`;
                container.appendChild(img);

                const name = document.createElement('div');
                name.className = 'agent-name';
                name.textContent = agent.name;

                preview.appendChild(container);
                preview.appendChild(name);
            }

            // Mark as selected if it matches current agent
            if ((isNone && currentAgent === 'none') || (!isNone && agent.name === currentAgent)) {
                preview.classList.add('selected');
            }

            preview.addEventListener('click', () => selectAgent(isNone ? 'none' : agent.name));

            return preview;
        }

        let currentClippyAgent = null;

        function selectAgent(agentName) {
            fetch(`${BASE_URL}/api/settings/clippy-agent`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ agent_form: agentName })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentAgent = agentName;

                        // Update UI
                        document.querySelectorAll('.agent-preview').forEach(p => {
                            p.classList.remove('selected');
                        });
                        const selected = document.querySelector(`.agent-preview[data-agent="${agentName}"]`);
                        if (selected) selected.classList.add('selected');

                        // Immediately load the selected agent
                        if (agentName === 'none') {
                            // Hide current agent if any
                            if (currentClippyAgent) {
                                try {
                                    currentClippyAgent.hide(false, function () {
                                        currentClippyAgent._el.remove();
                                        currentClippyAgent._balloon._balloon.remove();
                                        currentClippyAgent = null;

                                    });
                                } catch (e) {
                                    currentClippyAgent = null;
                                }
                            }
                        } else {
                            // Load new agent
                            if (typeof clippy !== 'undefined') {
                                // Hide current agent if any, then load new one
                                if (currentClippyAgent) {
                                    try {
                                        var oldAgent = currentClippyAgent;
                                        currentClippyAgent = null;

                                        // Wait for hide animation to complete before cleaning up
                                        oldAgent.hide(false, function () {
                                            // After hide completes, remove old agent's DOM elements
                                            oldAgent._el.remove();
                                            oldAgent._balloon._balloon.remove();

                                            // NOW load the new agent
                                            clippy.load(agentName, function (agent) {
                                                currentClippyAgent = agent;
                                                window.currentClippyAgent = agent;
                                                if (window.hookClippySpeech) {
                                                    window.hookClippySpeech(agent);
                                                }

                                                // Position the agent manually before showing
                                                var margin = 16;
                                                var w = $(window).width();
                                                var h = $(window).height();
                                                var elW = agent._el.outerWidth() || 124;
                                                var elH = agent._el.outerHeight() || 93;
                                                var leftPos = Math.max(margin, w - elW - margin);
                                                var topPos = Math.max(margin, h - elH - margin);
                                                agent._el.css({ top: topPos, left: leftPos });

                                                // Use the built-in show() which handles Show animation properly
                                                agent.show();

                                                // Use setTimeout to ensure DOM has updated before positioning balloon
                                                setTimeout(function () {
                                                    // Get transformation phrase for the new agent
                                                    window.loadClippyPhrases().then(function (phrases) {
                                                        var agentPhrase = phrases.transformation && phrases.transformation[agentName.toLowerCase()]
                                                            ? phrases.transformation[agentName.toLowerCase()]
                                                            : 'Hello!';
                                                        agent.speak(agentPhrase);

                                                        try {
                                                            if (agent.hasAnimation && agent.hasAnimation('CheckingSomething')) {
                                                                agent.play('CheckingSomething', 5000);
                                                            }
                                                        } catch (e) { }
                                                    }).catch(function () {
                                                        agent.speak('Hello!');

                                                        try {
                                                            if (agent.hasAnimation && agent.hasAnimation('CheckingSomething')) {
                                                                agent.play('CheckingSomething', 5000);
                                                            }
                                                        } catch (e) { }
                                                    });
                                                }, 50);
                                            });
                                        });
                                    } catch (e) {
                                        // If hide fails, still clean up and load new agent
                                        if (currentClippyAgent) {
                                            currentClippyAgent._el.remove();
                                            currentClippyAgent._balloon._balloon.remove();
                                            currentClippyAgent = null;
                                        }

                                        clippy.load(agentName, function (agent) {
                                            currentClippyAgent = agent;
                                            window.currentClippyAgent = agent;
                                            if (window.hookClippySpeech) {
                                                window.hookClippySpeech(agent);
                                            }

                                            // Position the agent manually before showing
                                            var margin = 16;
                                            var w = $(window).width();
                                            var h = $(window).height();
                                            var elW = agent._el.outerWidth() || 124;
                                            var elH = agent._el.outerHeight() || 93;
                                            var leftPos = Math.max(margin, w - elW - margin);
                                            var topPos = Math.max(margin, h - elH - margin);
                                            agent._el.css({ top: topPos, left: leftPos });

                                            // Use the built-in show() which handles Show animation properly
                                            agent.show();

                                            // Use setTimeout to ensure DOM has updated before positioning balloon
                                            setTimeout(function () {
                                                // Get transformation phrase for the new agent
                                                window.loadClippyPhrases().then(function (phrases) {
                                                    var agentPhrase = phrases.transformation && phrases.transformation[agentName.toLowerCase()]
                                                        ? phrases.transformation[agentName.toLowerCase()]
                                                        : 'Hello!';
                                                    agent.speak(agentPhrase);

                                                    try {
                                                        if (agent.hasAnimation && agent.hasAnimation('CheckingSomething')) {
                                                            agent.play('CheckingSomething', 5000);
                                                        }
                                                    } catch (e) { }
                                                }).catch(function () {
                                                    agent.speak('Hello!');

                                                    try {
                                                        if (agent.hasAnimation && agent.hasAnimation('CheckingSomething')) {
                                                            agent.play('CheckingSomething', 5000);
                                                        }
                                                    } catch (e) { }
                                                });
                                            }, 50);
                                        });
                                    }
                                } else {
                                    // No current agent, load immediately
                                    clippy.load(agentName, function (agent) {
                                        currentClippyAgent = agent;
                                        window.currentClippyAgent = agent;
                                        if (window.hookClippySpeech) {
                                            window.hookClippySpeech(agent);
                                        }

                                        // Position the agent BEFORE showing it
                                        agent._hidden = false;
                                        var margin = 16;
                                        var w = $(window).width();
                                        var h = $(window).height();
                                        var elW = agent._el.outerWidth() || 124;
                                        var elH = agent._el.outerHeight() || 93;
                                        var leftPos = Math.max(margin, w - elW - margin);
                                        var topPos = Math.max(margin, h - elH - margin);
                                        agent._el.css({ top: topPos, left: leftPos });
                                        agent._el.show();
                                        agent.resume();
                                        agent._onQueueEmpty();

                                        try {
                                            if (agent.hasAnimation && agent.hasAnimation('CheckingSomething')) {
                                                agent.play('CheckingSomething', 5000);
                                            }
                                        } catch (e) { }
                                    });
                                }
                            }
                        }

                        // Show feedback
                        const msgEl = document.getElementById('agent-message');
                        msgEl.innerHTML = `<div class="message success">Agent selection saved${agentName === 'none' ? ' (Clippy disabled)' : ''}!</div>`;
                        setTimeout(() => msgEl.innerHTML = '', 3000);
                    } else {
                        alert('Error saving selection: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    alert('Error saving selection: ' + error);
                });
        }

        // Load agents and render selector
        fetch(`${BASE_URL}/api/clippy-agents`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    const container = document.getElementById('agentSelector');
                    if (!container) {
                        console.error('Agent selector container not found!');
                        return;
                    }

                    // Add "None" option first
                    container.appendChild(createAgentPreview(null, true));

                    // Add all agents
                    if (data.agents && Array.isArray(data.agents)) {
                        data.agents.forEach(agent => {
                            if (agent && agent.name) {
                                container.appendChild(createAgentPreview(agent));
                            } else {
                                console.warn('Invalid agent data:', agent);
                            }
                        });
                    } else {
                        console.warn('No agents array in response:', data);
                    }
                } else {
                    console.error('Error loading agents:', data.error || 'Unknown error');
                }
            })
            .catch(error => {
                console.error('Error loading agents:', error);
                const container = document.getElementById('agentSelector');
                if (container) {
                    container.innerHTML = '<div style="color: red; padding: 10px;">Error loading agents. Please refresh the page.</div>';
                }
            });

        // Show password change fields
        function showPasswordFields() {
            document.getElementById('password-fields').style.display = 'block';
            document.getElementById('show-password-fields-btn').style.display = 'none';
            document.getElementById('current-password').focus();
        }

        // Hide password change fields
        function hidePasswordFields() {
            document.getElementById('password-fields').style.display = 'none';
            document.getElementById('show-password-fields-btn').style.display = 'inline-block';
            // Clear fields
            document.getElementById('current-password').value = '';
            document.getElementById('new-password').value = '';
            document.getElementById('confirm-password').value = '';
            // Clear message
            document.getElementById('password-message').innerHTML = '';
        }

        // Password change function
        function submitPasswordChange() {
            const currentPassword = document.getElementById('current-password').value;
            const newPassword = document.getElementById('new-password').value;
            const confirmPassword = document.getElementById('confirm-password').value;
            const messageDiv = document.getElementById('password-message');

            // Clear previous messages
            messageDiv.innerHTML = '';
            messageDiv.style.display = 'none';

            // Validation
            if (!currentPassword || !newPassword || !confirmPassword) {
                messageDiv.innerHTML = '<div class="message error">All fields are required</div>';
                messageDiv.style.display = 'block';
                return;
            }

            if (newPassword !== confirmPassword) {
                messageDiv.innerHTML = '<div class="message error">New passwords do not match</div>';
                messageDiv.style.display = 'block';
                return;
            }

            if (newPassword.length < 4) {
                messageDiv.innerHTML = '<div class="message error">Password must be at least 4 characters</div>';
                messageDiv.style.display = 'block';
                return;
            }

            // Send request
            fetch(`${BASE_URL}/api/settings/change-password`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    current_password: currentPassword,
                    new_password: newPassword,
                    confirm_password: confirmPassword
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Show success message
                        messageDiv.innerHTML = '<div class="message success" style="transition: opacity 0.5s;">' + data.message + '</div>';
                        messageDiv.style.display = 'block';

                        // Wait 2 seconds, then fade out and hide fields
                        setTimeout(() => {
                            const successMsg = messageDiv.querySelector('.message.success');
                            if (successMsg) {
                                successMsg.style.opacity = '0';
                                // After fade completes, hide everything
                                setTimeout(() => {
                                    hidePasswordFields();
                                    messageDiv.style.display = 'none';
                                }, 500);
                            }
                        }, 2000);
                    } else {
                        messageDiv.innerHTML = '<div class="message error">' + data.error + '</div>';
                        messageDiv.style.display = 'block';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    messageDiv.innerHTML = '<div class="message error">An error occurred. Please try again.</div>';
                    messageDiv.style.display = 'block';
                });
        }

        // Allow Enter key to submit password change
        ['current-password', 'new-password', 'confirm-password'].forEach(id => {
            document.getElementById(id).addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    submitPasswordChange();
                }
            });
        });

        // Load and set privacy mode
        fetch(`${BASE_URL}/api/settings/privacy-mode`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const radio = document.querySelector(`input[name="privacy-mode"][value="${data.privacy_mode}"]`);
                    if (radio) {
                        radio.checked = true;
                        updatePrivacyModeStyles();
                    }
                }
            })
            .catch(error => console.error('Error loading privacy mode:', error));

        // Handle privacy mode change
        document.querySelectorAll('input[name="privacy-mode"]').forEach(radio => {
            radio.addEventListener('change', function () {
                const messageDiv = document.getElementById('privacy-mode-message');
                messageDiv.innerHTML = '';

                fetch(`${BASE_URL}/api/settings/privacy-mode`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        privacy_mode: this.value
                    })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            const modeName = this.value === 'private' ? 'Private' : 'Public';
                            messageDiv.innerHTML = `<div class="message success">Privacy mode set to ${modeName}</div>`;
                            updatePrivacyModeStyles();
                        } else {
                            messageDiv.innerHTML = '<div class="message error">' + data.error + '</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        messageDiv.innerHTML = '<div class="message error">An error occurred. Please try again.</div>';
                    });
            });
        });

        function updatePrivacyModeStyles() {
            document.querySelectorAll('input[name="privacy-mode"]').forEach(radio => {
                const label = radio.closest('label');
                if (radio.checked) {
                    label.style.borderColor = '#667eea';
                    label.style.backgroundColor = '#f0f4ff';
                } else {
                    label.style.borderColor = '#ddd';
                    label.style.backgroundColor = 'transparent';
                }
            });
        }

        // Disk usage monitoring
        function formatBytes(mb) {
            if (mb < 1024) {
                return mb.toFixed(2) + ' MB';
            }
            return (mb / 1024).toFixed(2) + ' GB';
        }

        function updateDiskUsage() {
            fetch(`${BASE_URL}/api/settings/disk-usage`, {
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        const bar = document.getElementById('disk-usage-bar');
                        const info = document.getElementById('disk-usage-info');
                        const description = document.getElementById('disk-usage-description');
                        
                        // Update progress bar
                        const percent = data.percent_used;
                        bar.style.width = percent + '%';
                        bar.setAttribute('data-percent', percent.toFixed(1) + '%');
                        
                        // Color based on usage
                        if (percent < 70) {
                            bar.style.backgroundColor = '#10b981'; // Green
                        } else if (percent < 90) {
                            bar.style.backgroundColor = '#f59e0b'; // Orange
                        } else {
                            bar.style.backgroundColor = '#ef4444'; // Red
                        }
                        
                        // Update info display
                        if (data.quota_configured) {
                            description.textContent = `Monitoring disk quota: ${formatBytes(data.disk_quota_mb)} total`;
                            
                            info.innerHTML = `
                                <div class="disk-usage-stat">
                                    <div class="label">Current Usage</div>
                                    <div class="value">${formatBytes(data.current_usage_mb)}</div>
                                </div>
                                <div class="disk-usage-stat">
                                    <div class="label">Quota Limit</div>
                                    <div class="value">${formatBytes(data.disk_quota_mb)}</div>
                                </div>
                                <div class="disk-usage-stat">
                                    <div class="label">Remaining</div>
                                    <div class="value">${formatBytes(data.remaining_mb)}</div>
                                </div>
                                <div class="disk-usage-stat">
                                    <div class="label">Used</div>
                                    <div class="value">${percent.toFixed(1)}%</div>
                                </div>
                            `;
                        } else {
                            description.textContent = `Monitoring filesystem: ${formatBytes(data.filesystem_total_mb)} total capacity`;
                            
                            info.innerHTML = `
                                <div class="disk-usage-stat">
                                    <div class="label">Instance Usage</div>
                                    <div class="value">${formatBytes(data.current_usage_mb)}</div>
                                </div>
                                <div class="disk-usage-stat">
                                    <div class="label">Filesystem Total</div>
                                    <div class="value">${formatBytes(data.filesystem_total_mb)}</div>
                                </div>
                                <div class="disk-usage-stat">
                                    <div class="label">Filesystem Free</div>
                                    <div class="value">${formatBytes(data.filesystem_free_mb)}</div>
                                </div>
                                <div class="disk-usage-stat">
                                    <div class="label">Disk Used</div>
                                    <div class="value">${percent.toFixed(1)}%</div>
                                </div>
                            `;
                        }
                    } else {
                        document.getElementById('disk-usage-description').textContent = 'Error loading disk usage: ' + data.error;
                    }
                })
                .catch(error => {
                    console.error('Error loading disk usage:', error);
                    document.getElementById('disk-usage-description').textContent = 'Error loading disk usage information';
                });
        }

        // Replicate usage monitoring (only shown when a managed quota is configured)
        function updateReplicateUsage() {
            fetch(`${BASE_URL}/api/settings/replicate-usage`, {
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const description = document.getElementById('replicate-usage-description');
                    const bar = document.getElementById('replicate-usage-bar');
                    const info = document.getElementById('replicate-usage-info');

                    if (!data.quota_configured) {
                        // No managed quota ‚Äì hide the entire section
                        const section = document.getElementById('replicate-usage-section');
                        if (section) section.style.display = 'none';
                        return;
                    }

                    const used = data.requests_used || 0;
                    const limit = data.quota_limit || 0;
                    const remaining = data.remaining_requests || 0;
                    const percent = data.percent_used || 0;

                    // Ensure section is visible when quota is configured
                    const section = document.getElementById('replicate-usage-section');
                    if (section) section.style.display = 'block';

                    // Update progress bar
                    bar.style.width = percent + '%';
                    bar.setAttribute('data-percent', percent.toFixed(1) + '%');

                    if (percent < 70) {
                        bar.style.backgroundColor = '#10b981'; // Green
                    } else if (percent < 90) {
                        bar.style.backgroundColor = '#f59e0b'; // Orange
                    } else {
                        bar.style.backgroundColor = '#ef4444'; // Red
                    }

                    description.textContent = `Managed Replicate quota: ${used} of ${limit} requests used`;

                    info.innerHTML = `
                        <div class="disk-usage-stat">
                            <div class="label">Requests Used</div>
                            <div class="value">${used}</div>
                        </div>
                        <div class="disk-usage-stat">
                            <div class="label">Quota Limit</div>
                            <div class="value">${limit}</div>
                        </div>
                        <div class="disk-usage-stat">
                            <div class="label">Remaining</div>
                            <div class="value">${remaining}</div>
                        </div>
                        <div class="disk-usage-stat">
                            <div class="label">Used</div>
                            <div class="value">${percent.toFixed(1)}%</div>
                        </div>
                    `;
                })
                .catch(error => {
                    console.error('Error loading Replicate usage:', error);
                    // On error, keep the section hidden so it doesn't clutter the UI
                    const section = document.getElementById('replicate-usage-section');
                    if (section) section.style.display = 'none';
                });
        }

        // Load disk and Replicate usage on page load (ensure DOM is ready)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                updateDiskUsage();
                updateReplicateUsage();
                loadVersionInfo();
            });
        } else {
            // DOM is already ready
            updateDiskUsage();
            updateReplicateUsage();
            loadVersionInfo();
        }

        // Version information
        function loadVersionInfo() {
            fetch(`${BASE_URL}/api/settings/version`, {
                credentials: 'same-origin',
                headers: {
                    'Accept': 'application/json'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        const container = document.getElementById('version-info-container');
                        const description = document.getElementById('version-description');
                        
                        // Update current version
                        const currentVersionDisplay = document.getElementById('current-version-display');
                        let currentVersionText = data.current_version || 'Not set';
                        // Handle commit-based version display for dev branch
                        if (currentVersionText.startsWith('commit:')) {
                            const commitHash = currentVersionText.replace('commit:', '');
                            currentVersionText = `commit: ${commitHash}`;
                        }
                        currentVersionDisplay.textContent = currentVersionText;
                        currentVersionDisplay.style.color = data.current_version ? '#374151' : '#9ca3af';
                        
                        // Update branch
                        const branchDisplay = document.getElementById('current-branch-display');
                        branchDisplay.textContent = data.current_branch || 'main';
                        
                        // Update available version
                        const availableVersionDisplay = document.getElementById('available-version-display');
                        if (data.available_version) {
                            // Handle commit-based version display for dev branch
                            if (data.available_version.startsWith('commit:')) {
                                const commitHash = data.available_version.replace('commit:', '');
                                availableVersionDisplay.textContent = `commit: ${commitHash}`;
                            } else {
                                availableVersionDisplay.textContent = data.available_version;
                            }
                            availableVersionDisplay.style.color = '#374151';
                        } else {
                            // Show appropriate message based on branch
                            if (data.current_branch === 'dev') {
                                availableVersionDisplay.textContent = 'Not a git repository';
                                availableVersionDisplay.style.color = '#f59e0b';
                            } else {
                                availableVersionDisplay.textContent = 'Checking...';
                                availableVersionDisplay.style.color = '#9ca3af';
                            }
                        }
                        
                        // Update status message
                        const updateStatusContainer = document.getElementById('update-status-container');
                        const updateStatusMessage = document.getElementById('update-status-message');
                        const updateButton = document.getElementById('update-button');
                        
                        if (data.update_available && data.needs_update) {
                            updateStatusContainer.style.display = 'block';
                            // Format update message based on version type
                            let updateMsg = 'üÜï Update available';
                            if (data.available_version) {
                                if (data.available_version.startsWith('commit:')) {
                                    const commitHash = data.available_version.replace('commit:', '');
                                    updateMsg = `üÜï New commits available (${commitHash})`;
                                } else {
                                    updateMsg = `üÜï Update available: ${data.available_version}`;
                                }
                            }
                            updateStatusMessage.textContent = updateMsg;
                            updateStatusMessage.style.color = '#059669';
                            if (updateButton) {
                                updateButton.style.display = 'block';
                            }
                        } else if (data.update_available && !data.needs_update) {
                            updateStatusContainer.style.display = 'block';
                            updateStatusMessage.textContent = '‚úÖ You are on the latest version';
                            updateStatusMessage.style.color = '#059669';
                            if (updateButton) {
                                updateButton.style.display = 'none';
                            }
                        } else {
                            updateStatusContainer.style.display = 'none';
                            if (updateButton) {
                                updateButton.style.display = 'none';
                            }
                        }
                        
                        // Show container and update description
                        container.style.display = 'block';
                        description.textContent = 'Current version and update information';
                    } else {
                        const description = document.getElementById('version-description');
                        description.textContent = 'Error loading version information';
                        description.style.color = '#ef4444';
                    }
                })
                .catch(error => {
                    console.error('Error loading version info:', error);
                    const description = document.getElementById('version-description');
                    description.textContent = 'Error loading version information';
                    description.style.color = '#ef4444';
                });
        }

        // Initiate update
        function initiateUpdate() {
            const updateButton = document.getElementById('update-button');
            if (updateButton) {
                updateButton.disabled = true;
                updateButton.textContent = 'üîÑ Updating...';
            }
            
            fetch(`${BASE_URL}/api/settings/update`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.redirect_url) {
                    // Redirect to login page with update parameter
                    window.location.href = data.redirect_url;
                } else {
                    alert(`Update failed: ${data.error || 'Unknown error'}`);
                    if (updateButton) {
                        updateButton.disabled = false;
                        updateButton.textContent = 'üîÑ Update Now';
                    }
                }
            })
            .catch(error => {
                console.error('Error initiating update:', error);
                alert('Error initiating update. Please try again.');
                if (updateButton) {
                    updateButton.disabled = false;
                    updateButton.textContent = 'üîÑ Update Now';
                }
            });
        }

        // Refresh disk usage every 30 seconds
        setInterval(updateDiskUsage, 30000);

        // Refresh Replicate usage every 10 seconds (more frequent for quota tracking)
        setInterval(updateReplicateUsage, 10000);
        
        // Load version info on page load
        loadVersionInfo();
        
        // Refresh usage when page becomes visible (e.g., after processing memes)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                updateDiskUsage();
                updateReplicateUsage();
            }
        });
    </script>
    <script src="{{ url_for('static', filename='jquery/jquery-3.7.1.min.js') }}"></script>
    <script src="{{ url_for('static', filename='clippy/build/clippy.js') }}"></script>
    <script src="{{ url_for('static', filename='js/clippy-phrases.js') }}"></script>
    <script src="{{ url_for('static', filename='js/clippy-session.js') }}"></script>
    <script src="{{ url_for('static', filename='js/clippy-debug.js') }}"></script>
    <script type="text/javascript">
        // Only load Clippy if agent is not 'none'
        {% if current_agent != 'none' %}
        try {
            initClippyWithSession('{{ current_agent }}', {
                useAnimations: false, // Use instant show during active session
                onLoad: function (agent, sessionState, willRestoreAnimation, clearSavedState, willSpeakQuip) {
                    try {
                        currentClippyAgent = agent;
                        try {
                            if (agent.hasAnimation && agent.hasAnimation('CheckingSomething')) {
                                // Page-specific animation should always play - clear saved state if restoring
                                if (willRestoreAnimation && clearSavedState) {
                                    clearSavedState();
                                }

                                // If a quip will be spoken, load and speak it first, then play animation
                                if (willSpeakQuip) {
                                    window.loadClippyPhrases().then(function () {
                                        var categories = window.getQuipCategoriesForPage();
                                        var quip = window.getRandomClippyPhrase(categories);
                                        agent.speak(quip);
                                        // Record that we spoke a quip
                                        localStorage.setItem('clippy_last_quip_time', Date.now().toString());
                                        localStorage.setItem('clippy_pages_since_quip', '0');
                                        // Animation will queue after the speech
                                        try {
                                            agent.play('CheckingSomething', 5000);
                                        } catch (playError) {
                                            console.warn('Could not play animation (audio permission may be required):', playError);
                                        }
                                    });
                                } else {
                                    // No quip, just play animation immediately
                                    try {
                                        agent.play('CheckingSomething', 5000);
                                    } catch (playError) {
                                        console.warn('Could not play animation (audio permission may be required):', playError);
                                    }
                                }
                            }
                        } catch (animError) {
                            console.warn('Animation error:', animError);
                        }
                    } catch (showError) {
                        console.error('Error showing agent:', showError);
                    }
                }
            });
        } catch (loadError) {
            console.error('Error loading Clippy agent:', loadError);
        }
        {% endif %}
    </script>
</body>

</html>